[5.创建高性能的索引](#5-创建高性能的索引)

​	[5.1索引基础](#51-索引基础)

​	[5.2索引的三大优点](#52-索引的三大优点)







# 5. 创建高性能的索引

索引，MySQL也叫“键（key）”，是存储引擎用于快速找到记录的一种数据结构，这是索引的基本功能。

索引对于良好的性能非常关键。当表中的数据量越来越大时，索引对性能的影响越重要。

不恰当的索引，在数据量较小且负载较低时，对性能影响不大，当数据量逐渐增大时，性能会**急剧下降**

**索引优化是对查询性能优化的最有效的手段**。索引能轻易**将查询性能提高几个数量级。**

“最优”的索引有时会比一个“好的”索引性能要好2个数量级。

创建一个真正”最优“索引经常需要重写查询。-- ?

---

### 5.1 索引基础

* **索引是如何工作的？**

例子：你想要在一本书中找到某个特定的主题，你可以去看看这本书的”索引“（可以理解为目录）部分，然后就可以找到对应的页码。

在MySQL中，存储引擎用以上类似的方法使用索引，其先在索引中找到对于的值，然后根据匹配的索引记录找到对应的数据行。

通过`SELECT user_name FROM cust_user where user_id = 5 `来分析索引：

假设在`user_id`列上建有索引，MySQL将使用该索引找到`user_id = 5`的行，也就是说，**MySQL会先在索引上按值进行查找，然后返回所有包含该值的数据行。**

---

* **索引可以包含一个或多个列的值**

**如果索引包含多个列，那么列的顺序十分重要，**因为**MySQL只能高效地使用索引的最左前缀列。**

创建一个包含2个列的索引，和创建2个只包含1列的索引是大不相同的。

---

#### 5.1.1索引的类型

并没有统一的索引标准：不同的存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。

即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

**MySQL中，索引是在存储引擎层实现的，而非服务器层**

以下是MySQL支持的索引类型

---

* **B-Tree索引（Balanced Tree）**

  谈论索引时，没有特别指明类型，我们大多数说的是B-Tree索引，其**使用B-Tree数据结构来存储数据**。大多数MySQL引擎都支持这种索引。Archive引擎是一个例外：5.1之前不支持任何索引，5.1开始才开始支持单个自增列（AUTO_INCREMENT）的索引。

  底层的存储引擎也可能使用不同的存储结构。NDB集群存储引擎内部实际上使用了T-Tree结构存储；InnoDB则是使用B+Tree

  存储引擎以不同的方式使用B-Tree索引，性能各不相同，各有优劣。**MyISAM使用前缀压缩技术使得索引更小，InnoDB则按照原数据格式进行存储。MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。**

  **B-Tree**通常意味着**所有的值都是按顺序存储，并且每一个叶子页到跟的距离相同**。

  **B-Tree数据结构如下**

  ![B-Tree数据结构](../pics/高性能MySQL/5-1-1-pic1.png)

  参考文章：[B-Tree索引详解及联合索引使用](https://blog.csdn.net/wdjxxl/article/details/79817445)

  ```markdown
  * 树形结构：由根节(root)、分支(branches)、叶(leaves)三级节点组成，其中分支节点可以有多层。
  * 多分支结构：与binary tree不相同的是，b-tree索引中单root/branch可以有多个子节点(超过2个)。
  * 双向链表：整个叶子节点部分是一个双向链表(后面会描述这个设计的作用)
  * 单个数据块中包括多条索引记录
  
  1. 理论上，使用B-tree在亿条数据与100条数据中定位记录的花销相同。
  2. B-tree索引对结构的利用率很高，定位高效。当1千万条数据时，B-tree索引也是三层结构(依稀记得亿级数据才是3层与4层的分水岭)。定位记录仍只需要三次I/O。
  ```

  B-Tree索引优点：

  ​	**1. 数据结构利用率高、定位高效**

  ​	**2. 平衡扩张（每个叶子页到跟的距离相同）**

  B-Tree可能引起的问题：

  ​	**1. 单一方向扩展引起的索引竞争(Index Contention)**

  ​	**2. 索引枯萎(Index Browning)**

  B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据

  假设有如下数据表

  ```mysql
  CREATE TABLE people (
  last_name VARCHAR ( 50 ) NOT NULL,
  first_name VARCHAR ( 50 ) NOT NULL,
  dob date NOT NULL,
  gender enum ( 'm', 'f' ) NOT NULL,
  KEY ( last_name, first_name, dob ) 
  );
  ```

  **索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序**

  B-Tree索引适用于全键值、键值范围或键前缀查找，其中键前缀查找只适用于根据最左前缀的查找。具体对应如下类型：

  1. **全值匹配**

     全值匹配指的是和索引中所有列进行匹配，可用于查找姓名为Cuba Allen、出生于1987-09-09的人
     
2. **匹配最左前缀**
  
   可用于查找所有姓为Allen的人，即使用索引的第一列
  
3.  **匹配列前缀**
  
   也可以使用某一列值的开头部分。查找所有以A开头的姓的人，也只用到索引的第	一列
  
 4. **匹配范围值**
  
    可用于查找姓在Allen和Bruce之间的人，也只用到索引的第一列
  
 5. **精确匹配某一列并范围匹配另外一列**
  
    查找所有姓为Allen，并且名字是字母K开头的人

B-Tree索引的限制：

  1. 如果不是按照索引的最左列开始查找，则无法使用索引
  2. 不能跳过索引中的列
  3. 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找

---

* 哈希索引

  哈希索引基于哈希表实现，**只有精确匹配索引所有列的查询才有效。**对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。**哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针**

  MySQL中，只有Memory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，同时也支持B-Tree索引。**Memory引擎是支持非唯一哈希索引的，比较与众不同，多个和列的哈希值相同，索引会以链表的方式存放多个纪录指针到同一个哈希条目中**

  例子：

  ```mysql
  create table testhash(
   fname VARCHAR(50) NOT NULL,
   lname VARCHAR(50) NOT NULL,
   KEY USING HASH(fname)
  )ENGINE=MEMORY;
  ```

  `mysql> select * from testhash`

  | fname | lname   |
  | ----- | ------- |
  | Allen | William |
  | Bior  | Michael |
  | Peter | Ben     |

  假设索引使用的哈希函数f()，它返回下面的值

  ```
  f('Allen') = 2323
  f('Bior') = 7623
  f('Peter') = 2458
  ```

  则哈希索引的数据结果如下：

  | 槽（Slot) | 值（Value)      |
  | --------- | --------------- |
  | 2323      | 指向第1行的指针 |
  | 2458      | 指向第3行的指针 |
  | 7623      | 指向第2行的指针 |

  每个槽的编号是顺序的，但是数据行不是。

  执行以下查询时：

  `select * from testhash where fname = 'Peter';`

  MySQL先计算‘``Petet'``的哈希值，并使用该值寻找对应的记录指针。因为`f('Peter') = 2458`，所以MySQL在索引中查找2458，可以找到指向第三行的指针，最后一步是比较第三行的值是否为`'Peter'`，以确保就是要查找的行。

  **因为哈希索引只需存储对应的哈希值，所以索引的结构非常紧凑，这也让哈希索引查找的速度非常快。**

  哈希索引也有**限制**：

  1. 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。但由于，访问内存中的行的速度非常快，大部分情况下可以忽略这一点
  2. 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
  3. 哈希索引也不支持索引列匹配查找，因为**哈希索引始终是使用索引列的全部内容来计算哈希值的。**如在数据列（A，B）上建立哈希索引，如果查询只有数据列A，则无法使用该索引
  4. **哈希索引只支持等值比较查询，包括`=、IN()、<=>(严格比较两个NULL值是否相等,两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0)。`也不支持任何范围查找，例如`where price > 100`**
  5. 访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。**当出现哈希冲突时，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行**
  6. 如果哈希冲突很多的话，一些索引维护操作的代价也会很高。如在某个选择性很低（哈希冲突）很多的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的某一行，找到并删除对应行的引用，冲突越多，代价越大
  
  因为这些限制，哈希索引只适用于某些特定的场合。而一旦适合哈希索引，它带来的性能提升将非常显著。举例：在数据仓库应用中，有一种经典的“星型”schema，需要关联很多查找表，哈希索引就非常适合查找表的需求。
  
  除了Memory引擎外，NDB集群引擎也支持唯一哈希索引，且在NDB集群引擎中作用非常特殊。
  
  InnoDB有一个特殊的功能叫`"自适应哈希索引”`。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再建立一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。但这是一个完全自动的、内部的行为，用户无法控制或者配置，如果有必要，可以完全关闭该功能。
  
  **创建自定义哈希索引**，如果存储引擎不支持哈希索引，则可以模拟InnoDB一样创建哈希索引，这样可以享受一些哈希索引的遍历。思路如下：
  
  在B-Tree索引基础上创建一个伪哈希索引。这和真正的哈希索引不是一回事，因为还是使用B-Tree进行查找，但是它使用哈希值而不是键本身进行索引查找。你需要做的就是在查询的WHERE子句中手动指定使用哈希函数。
  
  例如：需要存储大量的URL，并需要根据URL进行搜索查找。如果使用B-Tree来存储URL，存储的内容就会很大，因为URL本身很长。执行如下查询：
  
  `select id from url where url = 'http://www.mysql.com';`
  
  可以删除原来URL列上的索引，而**新增一个被索引的url_crc列**，使用CRC32做哈希，就可以使用下面的方式查询：
  
  `select id from url where url = 'http://www.mysql.com' and url_crc = CRC32('http://www.mysql.com');`
  
  这样做的性能会非常高，因为MySQL优化器会使用这个选择性很高而体积很小的基于url_crc列的索引来完成查找。**即使有多个记录有相同的索引值**，查找仍然很快，只需要根据哈希值做快速的整数比较就能找到索引条目，然后一一比较返回对应的行。另外一种方式就是对完整的URL字符串做索引，那样会非常慢。
  
  要避免哈希冲突问题，必须在`where`子句中带入哈希值`url_crc = CRC32('http://www.mysql.com')`和对应列值`url='http://www.mysql.com'`。

---

* 空间数据索引（R-Tree）

  MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据

---

* 全文索引

  全文索引是一种特殊类型的索引，它**查找的是文本中的关键词**，而不是直接比较索引中的值。全文索引和其他几类索引的匹配方式完全不一样，需要注意很多细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的WHERE条件匹配。

  在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作

---

### 5.2 索引的三大优点

1. 索引大大减少了服务器需要扫描的数据量
2. 索引可以帮助服务器避免排序和临时表
3. 索引可以将随机I/O变为顺序I/O

---

### 5.3 高性能的索引策略

* 独立的列

  如果查询中的列不是独立的，则MySQL就不会使用索引。**“独立的列”是指索引不能是表达式的一部分，也不能使函数的参数。**

  下列查询无法使用列的索引：

  `select actot_id from actor.actot_id + 1 =5;`

  `select ... where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;`

  **应该养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。**

* 前缀索引和索引选择性

  有时候索引很长的字符列，会让索引变得大且慢。一个策略是模拟哈希索引；另外一种**可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率，劣势是会降低索引的选择性。**索引的选择性是指，不重复的索引值（也叫基数）和数据表的记录总数（#T）的比值，范围从1/#T到1之间。索引的选择性越高，查询效率也高，选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，是最好的索引选择性，性能也是最好的。
  
  一般情况下某个前缀的选择性也是足够高的，足以满足查询性能。**对于BOLB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。**
  
  诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。
  
  **决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表来进行比较。**通过`city_demo表`来演示：
  
  1.计算完整列的选择性：
  
  `select count(distinct city)/count(*) form city_demo;`
  
  | count(distinct city)/count(*) |
  | ----------------------------- |
  | 0.0312                        |
  
  2.计算不同前缀长度的选择性
  
  ```mysql
  select count(distinct left(city,3))/count(*) as sel3,
  	count(distinct left(city,4))/count(*) as sel4,
  	count(distinct left(city,5))/count(*) as sel5,
  	count(distinct left(city,6))/count(*) as sel6,
  	count(distinct left(city,7))/count(*) as sel7 
  	form city_demo;
  ```
  
  | sel3   | sel4   | sel5   | sel6   | sel7   |
  | ------ | ------ | ------ | ------ | ------ |
  | 0.0239 | 0.0293 | 0.0305 | 0.0309 | 0.0310 |
  
  3.单看上面前缀长度的平均选择性还是不够，还要确保数据分布均匀
  
  `mysql> select count(*) as cnt,city from city_demo group by city order by cnt desc limit 10;`
  
  | cnt  | city           |
  | ---- | -------------- |
  | 65   | London         |
  | 49   | Hiroshima      |
  | 48   | Teboksary      |
  | 48   | Pak Kret       |
  | 47   | Tel Aviv-Jaffa |
  | 47   | Shimoga        |
  | 45   | Cabuyao        |
  | 45   | Callao         |
  | 45   | Bislig         |
  
  4.创建前缀索引：
  
  `alter table city_demo add key(city(7));`
  
  前缀索引可以使索引更小、更快，但是无法使用前缀索引做order by 和 group by,也无法使用前缀索引做覆盖扫描。
  
* 多列索引

  MySQL5.0和更新版本引入一种叫“索引合并”的策略
  
  ---
  
  \###复制解决了什么基本问题？
  
  使数据保持同步
  
  \###复制会不会带来额外的开销？
  
  复制通常不会增加主库的开销，主要是启用二进制日志带来的开销，但出于备份或及时从崩溃中恢复的目的，这点开销也是必要的。除此之外，每个备库也会对主库增加一些负载（例如网络I/O开销），尤其是当备库请求从主库读取旧的二进制文件时，可能会造成更高的I/O开销。通过复制可以获得更好的读扩展，但是对于写操作要慎重，在一主多备的架构中，写操作会被执行很多次，这时候整个系统的性能取决于写入最慢的部分。
  
  \###复制解决的问题：
  
  1. 数据分布 MySQL复制通常不会对带宽造成很大的压力
  2. 负载均衡 通过MySQL复制可以将读操作分布到多个服务器上,实现对读密集型应用的优化。
  3. 备份 对于备份来说,复制是一项很有意义的技术补充,但复制既不是备份也不能够取代备份。
  4. 高可用性和故障切换 复制能够帮助应用程序避免MySQL单点失败,一个包含复制的设计良好的故障切换系统能够显著地缩短宕机时间。
  
  [![img](https://camo.githubusercontent.com/e7ce125454d29d3acb6fe8e25e30c7a40f09d459/68747470733a2f2f6d6d62697a2e717069632e636e2f6d6d62697a5f6769662f5553313047636430745145666366667565593072654461543861674869624d626b36507163346962686963634f38507a30376d396a4a34657975505a566f6d78576961633546646963774233614f756231314371427a5851726a772f363430)](https://camo.githubusercontent.com/e7ce125454d29d3acb6fe8e25e30c7a40f09d459/68747470733a2f2f6d6d62697a2e717069632e636e2f6d6d62697a5f6769662f5553313047636430745145666366667565593072654461543861674869624d626b36507163346962686963634f38507a30376d396a4a34657975505a566f6d78576961633546646963774233614f756231314371427a5851726a772f363430)
  
  \###复制如何工作？
  
  [![img](https://camo.githubusercontent.com/f85be90b31a2f12ef8c54f5c41ecd3b1a94f1b35/68747470733a2f2f6d6d62697a2e717069632e636e2f6d6d62697a5f6a70672f6e3135464f31657550345549625163735462594b6835506c396e4b664c35567237744c4d456b39424d4d4369635145396a33584b596873513850756774625a3957614d4c545750655636716963497379455077566b5232772f3634303f77785f666d743d6a706567)](https://camo.githubusercontent.com/f85be90b31a2f12ef8c54f5c41ecd3b1a94f1b35/68747470733a2f2f6d6d62697a2e717069632e636e2f6d6d62697a5f6a70672f6e3135464f31657550345549625163735462594b6835506c396e4b664c35567237744c4d456b39424d4d4369635145396a33584b596873513850756774625a3957614d4c545750655636716963497379455077566b5232772f3634303f77785f666d743d6a706567)
  
  1. 在主库把数据修改记录以二进制的形式写入bin log（在每次准备提交事务完成数据更新前主库写入bin log日志，Mysql会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志，在记录bin log后，主库会告诉存储引擎可以提交错误了）
  2. 备库使用一个I/O线程将bin log日志读取到自己的中继（relay log）日志中（I/O线程跟主库建立一个普通的客户端连接。然后在主库上启动一个特殊的二进制转储（binlog dump）线程会读取主库上二进制文件中的事件，它不会对事件进行轮循。如果该线程追上主库线程的读取速度，那么它将进入休眠状态，直到主库发出信号量通知才会被唤醒）
  3. 备库的SQL线程读取中继日志的时间，在本地执行提交。
  
  \###主备库同步的条件：
  
  1. 在某个时间点的主库的数据快照
  2. 主库当前的二进制文件，和获得数据快照时在该二进制日志文件中的偏移量，这两个值可以确认一个唯一的日志文件坐标。
  3. 从快照到现在的二进制文件
  
  \###**复制的原理**
  
  1. 基于语句的复制
  
     在MySQL 5.0 及之前的版本中只支持基于语句的复制( 也称为逻辑复制)，基于语句的复制模式下，主库会记录那些造成数据更改的查询，当备库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行遍。这种方式既有好处，也有缺点。最明显的好处是实现相当简单。理论上讲，简单地记录和执行这些语句，能够让主备保持同步。另一个好处是二进制日志里的事件更加紧凑，所以相对而言，基于语句的模式不会使用太多带宽。一条更新好几兆数据的语句在二进制日志里可能只占几十个字节。另外mysqlbinlog工具(本章多处会提到)是使用基于语句的日志的最佳工具。但事实上基于语句的方式可能并不如其看起来那么便利。因为主库上的数据更新除了执行的语句外，可能还依赖于其他因素。例如，同一条SQL在主库和备库上执行的时间可能稍微或很不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的SQL.例如，使用CURRENT USER() 函数的语句。存储过程和触发器在使用基于语句的复制模式时也可能存在问题。 另外一个问题是更新必须是串行的。这需要更多的锁有时候要特别关注这一点。另外不是所有的存储引擎都支持这种复制模式。尽管这些存储引擎是包括在MySQL 5.5及之前版本中发行的。
  
  2. 基于行的复制
  
     MySQL 5.1开始支持基于行的复制，这种方式会将实际数据记录在二进制日志中，跟其他数据库的实现比较相像。它有其自身的一些优点和缺点。最大的好处是可以正确的复制每一行。一些语句可以被更加有效地复制。
  
     由于无须重放更新主库数据的查询，使用基于行的复制模式能够更高地复制数据。重放一些查询的代价可能会很高。例如，下面有一个查将数据从一个大表中汇总到小表：
  
     mysql> INSERT INTO summary_table(col1, col2, sum_col3)
  
     SELECT col1, col2, sum(col3)
  
     FROM enormous_table
  
     GROUP BY col1, col2;
  
     想象一下，如果表enormous_tabled 列col1和col2有三种组合，这个查询可能在源表上扫描多次，但最终只在目标表上产生三行数据。但使用基于行的复制方式，在备库上开销会小很多。这种情况下，基于行的复制模式更加高效。
  
     但在另一方面，下面这条语句使用基于语句的复制方式代价会小很多：
  
     mysql> UPDATE enormous_table SET col1=0;
  
     由于这条语句做了全表更新，使用基于行的复制开销会很大，因为每一行的数据都会被记录到二进制日志中，这使得二进制日志事件非常庞大。并且会给主库上记录日志和复制增加额外的负载，更慢的日志记录则会降低并发度。
  
     由于没有那种模式对所有情况都是完美的，MySQL能够在这两种复制模式间动态切换，默认情况下使用的是基于语句的复制方式，但如果发现语句无法正确地复制，就切换到基于行的复制模式。还可以根据需要来设置会话级别的变量binlog_format，控制二进制日志格式。
  
     对于基于行的复制模式，很难进行时间点恢复，但这并非不可能。

