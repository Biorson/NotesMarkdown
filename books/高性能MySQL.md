[5.创建高性能的索引](#5-创建高性能的索引)

​	[5.1索引基础](#51-索引基础)







# 5. 创建高性能的索引

索引，MySQL也叫“键（key）”，是存储引擎用于快速找到记录的一种数据结构，这是索引的基本功能。

索引对于良好的性能非常关键。当表中的数据量越来越大时，索引对性能的影响越重要。

不恰当的索引，在数据量较小且负载较低时，对性能影响不大，当数据量逐渐增大时，性能会**急剧下降**

**索引优化是对查询性能优化的最有效的手段**。索引能轻易**将查询性能提高几个数量级。**

“最优”的索引有时会比一个“好的”索引性能要好2个数量级。

创建一个真正”最优“索引经常需要重写查询。-- ?

---

### 5.1 索引基础

* **索引是如何工作的？**

例子：你想要在一本书中找到某个特定的主题，你可以去看看这本书的”索引“（可以理解为目录）部分，然后就可以找到对应的页码。

在MySQL中，存储引擎用以上类似的方法使用索引，其先在索引中找到对于的值，然后根据匹配的索引记录找到对应的数据行。

通过`SELECT user_name FROM cust_user where user_id = 5 `来分析索引：

假设在`user_id`列上建有索引，MySQL将使用该索引找到`user_id = 5`的行，也就是说，**MySQL会先在索引上按值进行查找，然后返回所有包含该值的数据行。**

---

* **索引可以包含一个或多个列的值**

**如果索引包含多个列，那么列的顺序十分重要，**因为**MySQL只能高效地使用索引的最左前缀列。**

创建一个包含2个列的索引，和创建2个只包含1列的索引是大不相同的。

---

#### 5.1.1索引的类型

并没有统一的索引标准：不同的存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。

即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

**MySQL中，索引是在存储引擎层实现的，而非服务器层**

以下是MySQL支持的索引类型

---

* **B-Tree索引（Balanced Tree）**

  谈论索引时，没有特别指明类型，我们大多数说的是B-Tree索引，其**使用B-Tree数据结构来存储数据**。大多数MySQL引擎都支持这种索引。Archive引擎是一个例外：5.1之前不支持任何索引，5.1开始才开始支持单个自增列（AUTO_INCREMENT）的索引。

  底层的存储引擎也可能使用不同的存储结构。NDB集群存储引擎内部实际上使用了T-Tree结构存储；InnoDB则是使用B+Tree

  存储引擎以不同的方式使用B-Tree索引，性能各不相同，各有优劣。**MyISAM使用前缀压缩技术使得索引更小，InnoDB则按照原数据格式进行存储。MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。**

  **B-Tree**通常意味着**所有的值都是按顺序存储，并且每一个叶子页到跟的距离相同**。

  **B-Tree数据结构如下**

  ![B-Tree数据结构](../pics/高性能MySQL/5-1-1-pic1.png)

  参考文章：[B-Tree索引详解及联合索引使用](https://blog.csdn.net/wdjxxl/article/details/79817445)

  ```markdown
  * 树形结构：由根节(root)、分支(branches)、叶(leaves)三级节点组成，其中分支节点可以有多层。
  * 多分支结构：与binary tree不相同的是，b-tree索引中单root/branch可以有多个子节点(超过2个)。
  * 双向链表：整个叶子节点部分是一个双向链表(后面会描述这个设计的作用)
  * 单个数据块中包括多条索引记录
  
  1. 理论上，使用B-tree在亿条数据与100条数据中定位记录的花销相同。
  2. B-tree索引对结构的利用率很高，定位高效。当1千万条数据时，B-tree索引也是三层结构(依稀记得亿级数据才是3层与4层的分水岭)。定位记录仍只需要三次I/O。
  ```

  B-Tree索引优点：

  ​	**1. 数据结构利用率高、定位高效**

  ​	**2. 平衡扩张（每个叶子页到跟的距离相同）**

  B-Tree可能引起的问题：

  ​	**1. 单一方向扩展引起的索引竞争(Index Contention)**

  ​	**2. 索引枯萎(Index Browning)**




